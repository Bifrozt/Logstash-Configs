# Author: Justin Henderson
# Email: jhenderson@tekrefresh.comes
# Last Update: 11/18/2015
#
# This conf file is based on accepting logs for conn.log from Bro systems
input {
  tcp {
    port => 6000
    type => "bro_conn"
  }
}

filter {
  if [type] == "bro_conn" {
    # This is the initial parsing of the log
    grok {
      match => [ 
      "message", "(?<ts>(.*?))\t(?<uid>(.*?))\t(?<SrcIP>(.*?))\t(?<SrcPort>(.*?))\t(?<DstIP>(.*?))\t(?<DstPort>(.*?))\t(?<proto>(.*?))\t(?<service>(.*?))\t(?<duration>(.*?))\t(?<orig_bytes>(.*?))\t(?<resp_bytes>(.*?))\t(?<conn_state>(.*?))\t(?<local_orig>(.*?))\t(?<missed_bytes>(.*?))\t(?<history>(.*?))\t(?<orig_pkts>(.*?))\t(?<orig_ip_bytes>(.*?))\t(?<resp_pkts>(.*?))\t(?<resp_ip_bytes>(.*?))\t(?<tunnel_parents>(.*?))\t(?<orig_cc>(.*?))\t(?<resp_cc>(.*?))\t(?<sensorname>(.*))",
      "message", "(?<ts>(.*?))\t(?<uid>(.*?))\t(?<SrcIP>(.*?))\t(?<SrcPort>(.*?))\t(?<DstIP>(.*?))\t(?<DstPort>(.*?))\t(?<proto>(.*?))\t(?<service>(.*?))\t(?<duration>(.*?))\t(?<orig_bytes>(.*?))\t(?<resp_bytes>(.*?))\t(?<conn_state>(.*?))\t(?<local_orig>(.*?))\t(?<missed_bytes>(.*?))\t(?<history>(.*?))\t(?<orig_pkts>(.*?))\t(?<orig_ip_bytes>(.*?))\t(?<resp_pkts>(.*?))\t(?<resp_ip_bytes>(.*?))\t(%{NOTSPACE:tunnel_parents})"
      ]
    }
	# Replace the host field with the host found in the bro log
    if [bro_host] {
      mutate {
        replace => [ "host", "%{bro_host}" ]
      }
    }
	# If duration is unspecified set it to zero so it is an integer
    if [duration] == "-" {
      mutate {
        replace => [ "duration", "0" ]
      }
    }
	# If orig_bytes is unspecified set it to zero so it is an integer
    if [orig_bytes] == "-" {
      mutate {
        replace => [ "orig_bytes", "0" ]
      }
    }
	# If resp_bytes is unspecified set it to zero so it is an integer
    if [resp_bytes] == "-" {
      mutate {
        replace => [ "resp_bytes", "0" ]
      }
    }
	# I recommend changing the field types below to integer or floats so searches can do greater than or less than
	# and also so math functions can be ran against them
    mutate {
      convert => [ "SrcPort", "integer" ]
      convert => [ "DstPort", "integer" ]
      convert => [ "orig_bytes", "integer" ]
      convert => [ "resp_bytes", "integer" ]
      convert => [ "missed_bytes", "integer" ]
      convert => [ "orig_pkts", "integer" ]
      convert => [ "orig_ip_bytes", "integer" ]
      convert => [ "resp_pkts", "integer" ]
      convert => [ "resp_ip_bytes", "integer" ]
      convert => [ "duration", "float" ]
    }
	# Combine orig_bytes and resp_bytes and save the value to total_bytes
	if [orig_bytes] {
	  if [resp_bytes] {
        ruby {
          code => "event['total_bytes'] = event['orig_bytes'] + event['resp_bytes']"
	    }
    }
	}
	# Add a socket_pair field and a ip_pair field as it is useful for searching against or creating visualizations
	# and dashboards
    mutate {
      add_field => [ "socket_pair", "%{SrcIP}:%{SrcPort} %{DstIP}:%{DstPort}" ]
      add_field => [ "ip_pair", "%{SrcIP} %{DstIP}" ]
      convert => [ "total_bytes", "integer" ]   
    }
    date {
      match => [ "ts", "UNIX" ]
    }
	# If SrcIP is set try to do a geoip lookup.  This will only save a geoip if the SrcIP is not a private IP address
    if [SrcIP]  {
      geoip {
        source => "[SrcIP]"
      }
    }
	# If DstIP is set try to do a geoip lookup.  This will only save a geopip if the DstIP is not a private IP address
    if [DstIP]  {
      geoip {
        source => "[DstIP]"
      }
    }
	# If you'd like for IP addresses to be resolved to DNS names uncomment this section
	# On conn.log this can generate a TON of DNS requests
	#
    #if [SrcIP] {
    #  if ![SrcIP-resolved] {
    #    mutate {
    #      add_field => [ "SrcIP-resolved", "%{SrcIP}" ]
    #    }
    #    dns {
    #      reverse => [ "SrcIP-resolved" ]
    #      action => "replace"
    #    }
    #  }
    #}
    #if [DstIP] {
    #  if ![DstIP-resolved] {
    #    mutate {
    #      add_field => [ "DstIP-resolved", "%{DstIP}" ]
    #    }
    #    dns {
    #      reverse => [ "DstIP-resolved" ]
    #      action => "replace"
    #    }
    #  }
    #}  
  }
}

output {
  if [type] == "bro_conn" {
    #stdout { codec => rubydebug }
    elasticsearch {
	  # Due to the volume of bro logs I like to save them to a seperate index.  This makes it easy to change retention
	  # You can uncomment the index line below if you would like all logs to be in the same logstash index
      index => "bro-%{+YYYY.MM.dd}"
    }
  }
}
