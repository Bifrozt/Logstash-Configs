# This conf file is based on accepting logs for http.log from Bro systems
input {
  file {
    type => "bro_http"
    start_position => "end"
    sincedb_path => "/var/tmp/.bro_http_sincedb"
 
    #Edit the following path to reflect the location of your log files. You can also change the extension if you use something else
    path => "/nsm/bro/logs/current/http.log"
  }
}

filter {
  if [type] == "bro_http" {
    # This is the initial parsing of the log
    grok {
      match => [ "message", "(?<ts>(.*?))\t(?<uid>(.*?))\t(?<SourceIP>(.*?))\t(?<SourcePort>(.*?))\t(?<DestinationIP>(.*?))\t(?<DestinationPort>(.*?))\t(?<trans_depth>(.*?))\t(?<method>(.*?))\t(?<bro_host>(.*?))\t(?<uri>(.*?))\t(?<referrer>(.*?))\t(?<user_agent>(.*?))\t(?<request_body_len>(.*?))\t(?<response_body_len>(.*?))\t(?<status_code>(.*?))\t(?<status_msg>(.*?))\t(?<info_code>(.*?))\t(?<info_msg>(.*?))\t(?<filename>(.*?))\t(?<http_tags>(.*?))\t(?<username>(.*?))\t(?<password>(.*?))\t(?<proxied>(.*?))\t(?<orig_fuids>(.*?))\t(?<orig_mime_types>(.*?))\t(?<resp_fuids>(.*?))\t(?<resp_mime_types>(.*))" ]
    }
	# Replace the host field with the host found in the bro log
    if [bro_host] {
      mutate {
        replace => [ "host", "%{bro_host}" ]
      }
    }
	# I recommend changing the field types below to integer so searches can do greater than or less than
	# and also so math functions can be ran against them
    mutate {
      convert => [ "SourcePort", "integer" ]
      convert => [ "DestinationPort", "integer" ]
    }
    date {
      match => [ "ts", "UNIX" ]
    }
	# I recommend renaming user_agent to UserAgent to be more consistent with naming of other log sources
    mutate {
      rename => [ "user_agent", "UserAgent" ]
    }
	# If SourceIP is set try to do a geoip lookup.  This will only save a geoip if the SourceIP is not a private IP address
    if [SourceIP] and [type] == "bro_http" {
      geoip {
        source => "[SourceIP]"
      }
    }
	# If DestinationIP is set try to do a geoip lookup.  This will only save a geopip if the DestinationIP is not a private IP address
    if [DestinationIP] and [type] == "bro_http"  {
      geoip {
        source => "[DestinationIP]"
      }
    }
	# If SourceIP is set try to do a DNS reverse lookup
    if [SourceIP] {
      if ![SourceIP-resolved] {
        mutate {
          add_field => [ "SourceIP-resolved", "%{SourceIP}" ]
        }
        dns {
          reverse => [ "SourceIP-resolved" ]
          action => "replace"
        }
      }
    }
	# If DestinationIP is set try to do a DNS reverse lookup
    if [DestinationIP] {
      if ![DestinationIP-resolved] {
        mutate {
          add_field => [ "DestinationIP-resolved", "%{DestinationIP}" ]
        }
        dns {
          reverse => [ "DestinationIP-resolved" ]
          action => "replace"
        }
      }
    }
	# I recommend renaming username to Username to be more consistent with naming of other log sources
    mutate {
      rename => [ "username", "Username" ]
      remove_field => [ "bro_host" ]
    }
	# If uri exists run a frequency analysis against it.  In order for this to work you must have
	# freq.py and the corresponding frequency table in /opt/freq/.  This is a huge boost to security
	# and I highly recommend you set this up.  Example, if a frequency score less than 6 exists
	# then there is a likelihood that something malicious is happening.
	#
	# For higher accuracy, please generate your own frequency tables.  For questions on setup,
	# please refer to https://github.com/SMAPPER
  }
}

output {
  if [type] == "bro_http" {
    #stdout { codec => rubydebug }
    elasticsearch {
	  # Due to the volume of bro logs I like to save them to a seperate index.  This makes it easy to change retention
	  # You can uncomment the index line below if you would like all logs to be in the same logstash index
      index => "bro-%{+YYYY.MM.dd}"
    }
  }
}
